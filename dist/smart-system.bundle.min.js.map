{"version":3,"file":"smart-system.bundle.min.js","mappings":"mBA+c2CA,MAqIZC,YAgfCA,YAkC3BC,OAAOC,SA2CcF,YC3mCnB,MAAMG,EACTC,iBAA+C,GAC/C,UAAOC,CAAIC,GACP,IAAIC,EAAWC,KAAKC,UAAUC,MAAKH,GAAYA,EAASD,OAASA,IACjE,GAAgB,MAAZC,EAAkB,MAAM,IAAII,MAAM,0CAA0CL,iBAChF,OAAOC,CACX,CACA,kBAAOK,CAAYN,EAAcO,GAC7B,IAAIN,EAAWC,KAAKC,UAAUC,MAAKH,GAAYA,EAASD,OAASA,IACjE,OAAgB,MAAZC,IACJA,EAAW,IAAIJ,EAAyBG,EAAMO,GAC9CL,KAAKC,UAAUK,KAAKP,IAFWA,CAInC,CAAC,cAKGC,KAAKO,QAAUP,KAAKI,YAAY,EAAG,MALtC,GAQOI,WAAAA,CAA4BV,EAA8BO,GAAqB,KAAnDP,KAAAA,EAAY,KAAkBO,YAAAA,CAAuB,EA4CtF,MAAMI,EACDD,WAAAA,CAA4BE,GAA6B,KAA7BA,OAAAA,CAA+B,CAEnEd,gBAAwB,KAAuB,IAAIa,EAA3B,GAExBE,OAAAA,GACI,OAAO,IAAIF,EADmBG,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAGH,EAAmBV,SAExD,CAEAgB,oBAAAA,CAA6GC,GACzG,MAAMC,EAAmC,GACzC,IAAIC,EAA2ClB,KAC/C,KAAmB,MAAZkB,GACHD,EAAWX,KAAKY,GAChBA,EAAWA,EAASR,OAExB,OAAOM,EAAOG,YAAYC,QAAOC,GAAcJ,EAAWK,SAASD,EAAWH,WAClF,CAEA,WAAMK,CAA8FP,EAA+CQ,GAC/I,OAAOR,EAAOS,OAAOD,EAASxB,KAClC,E","sources":["webpack://Uoyroem/./lib/core/form.ts","webpack://Uoyroem/./lib/core/form-action.ts"],"sourcesContent":["import { EffectManager } from \"./effect-manager\";\r\nexport { EffectManager };\r\n\r\nfunction deepEqual(a: any, b: any): boolean {\r\n    if (a === b) return true;\r\n\r\n    if (typeof a !== \"object\" || typeof b !== \"object\" || a === null || b === null) {\r\n        return false;\r\n    }\r\n\r\n    const aKeys = new Set(Object.keys(a));\r\n    const bKeys = new Set(Object.keys(b));\r\n\r\n    if (aKeys.size !== bKeys.size) return false;\r\n    for (const key of aKeys) {\r\n        if (!deepEqual(a[key], b[key])) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nexport function getMetaDependencyKey(fieldName: string, metaKey: string) {\r\n    return `${fieldName}:${metaKey}`;\r\n}\r\n\r\n\r\n\r\nexport class FormFieldValidator {\r\n    public name: string;\r\n\r\n    constructor(name: string) {\r\n        this.name = name;\r\n    }\r\n\r\n    validate(field: FormField) {\r\n\r\n    }\r\n}\r\n\r\nexport class FormFieldValidatorRequired extends FormFieldValidator {\r\n    constructor() {\r\n        super(\"Required\");\r\n    }\r\n\r\n    validate(field: FormField): void {\r\n\r\n    }\r\n}\r\n\r\nexport type FormElement = HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement;\r\n\r\nexport enum FormFieldTypeElementStatus {\r\n    VALUE_SUCCESSFULLY_RECEIVED = \"value-successfully-received\",\r\n    VALUE_SET_SUCCESS = \"value-set-success\",\r\n    META_VALUE_SUCCESSFULLY_RECEIVED = \"meta-value-successfully-received\",\r\n    META_VALUE_SET_SUCCESS = \"meta-value-set-success\",\r\n    FAILED_TO_SET_VALUE = \"failed-to-set-value\",\r\n    FAILED_TO_SET_META_VALUE = \"failed-to-set-meta-value\",\r\n    INVALID_ELEMENT = \"invalid-element\",\r\n    TYPE_MISMATCH = \"type-mismatch\",\r\n    META_KEY_NOT_EXISTS = \"meta-key-not-exists\"\r\n}\r\n\r\nexport class FormFieldType {\r\n    static object() {\r\n        return new FormFieldTypeObject();\r\n    }\r\n\r\n    static text() {\r\n        return new FormFieldTypeText();\r\n    }\r\n\r\n    static number() {\r\n        return new FormFieldTypeNumber();\r\n    }\r\n\r\n    static date() {\r\n        return new FormFieldTypeDate();\r\n    }\r\n\r\n    static select({ multiple = false } = {}) {\r\n        return new FormFieldTypeSelect().multiple(multiple);\r\n    }\r\n\r\n    static checkbox() {\r\n        return new FormFieldTypeCheckbox();\r\n    }\r\n\r\n    static radio() {\r\n        return new FormFieldTypeRadio();\r\n    }\r\n\r\n    static isFormElement(element: Element): element is FormElement {\r\n        return element instanceof HTMLInputElement || element instanceof HTMLSelectElement || element instanceof HTMLTextAreaElement;\r\n    }\r\n\r\n    static fromFormElement(element: FormElement): FormFieldType {\r\n        switch (element.type) {\r\n            case \"select-one\":\r\n                return this.select();\r\n            case \"select-multiple\":\r\n                return this.select().multiple();\r\n            case \"number\":\r\n                return this.number();\r\n            case \"text\":\r\n                return this.text();\r\n            case \"textarea\":\r\n                return this.text().area();\r\n            case \"checkbox\":\r\n                return this.checkbox();\r\n            case \"radio\":\r\n                return this.radio();\r\n            case \"date\":\r\n                return this.date();\r\n            default:\r\n                throw new Error(`As element type ${element} not has`);\r\n        }\r\n    }\r\n\r\n    public name: string;\r\n\r\n    constructor(name: string) {\r\n        this.name = name;\r\n    }\r\n\r\n    isEqual(a: any, b: any): boolean { return a === b; }\r\n    isEmpty() { }\r\n    asElementType() { return \"hidden\"; }\r\n\r\n    fetch() {\r\n    }\r\n\r\n    getFieldValue(field: FormField): any {\r\n        return field.getValue();\r\n    }\r\n\r\n    getFieldMetaValue(field: FormField, metaKey: string): any {\r\n        return field.getMetaValue(metaKey);\r\n    }\r\n\r\n    setFieldValue(field: FormField, newValue: any): Set<string> {\r\n        return field.setValue(newValue);\r\n    }\r\n\r\n    setFieldMetaValue(field: FormField, metaKey: string, newValue: any): Set<string> {\r\n        return field.setMetaValue(metaKey, newValue);\r\n    }\r\n\r\n    getElementValue(element: Element): [any, FormFieldTypeElementStatus] {\r\n        if (!FormFieldType.isFormElement(element)) {\r\n            return [null, FormFieldTypeElementStatus.INVALID_ELEMENT];\r\n        }\r\n        if (element.type !== this.asElementType()) {\r\n            return [null, FormFieldTypeElementStatus.TYPE_MISMATCH];\r\n        }\r\n        return [element.value, FormFieldTypeElementStatus.VALUE_SUCCESSFULLY_RECEIVED];\r\n    }\r\n\r\n    setElementValue(element: Element, newValue: any): FormFieldTypeElementStatus {\r\n        if (!FormFieldType.isFormElement(element)) {\r\n            return FormFieldTypeElementStatus.INVALID_ELEMENT;\r\n        }\r\n        if (element.type !== this.asElementType()) {\r\n            return FormFieldTypeElementStatus.TYPE_MISMATCH;\r\n        }\r\n        element.value = newValue;\r\n        return FormFieldTypeElementStatus.VALUE_SET_SUCCESS;\r\n    }\r\n\r\n    getElementMetaValue(element: Element, metaKey: string): [any, FormFieldTypeElementStatus] {\r\n        if (!FormFieldType.isFormElement(element)) {\r\n            return [undefined, FormFieldTypeElementStatus.INVALID_ELEMENT];\r\n        }\r\n        if (element.type !== this.asElementType()) {\r\n            return [undefined, FormFieldTypeElementStatus.TYPE_MISMATCH];\r\n        }\r\n        if (metaKey === \"disabled\") {\r\n            return [element.disabled, FormFieldTypeElementStatus.META_VALUE_SUCCESSFULLY_RECEIVED];\r\n        }\r\n        return [undefined, FormFieldTypeElementStatus.META_KEY_NOT_EXISTS]\r\n    }\r\n\r\n    setElementMetaValue(element: Element, metaKey: string, newValue: any): FormFieldTypeElementStatus {\r\n        if (!FormFieldType.isFormElement(element)) {\r\n            return FormFieldTypeElementStatus.INVALID_ELEMENT;\r\n        }\r\n        if (element.type !== this.asElementType()) {\r\n            return FormFieldTypeElementStatus.TYPE_MISMATCH;\r\n        }\r\n        if (metaKey === \"disabled\") {\r\n            element.disabled = Boolean(newValue);\r\n            return FormFieldTypeElementStatus.META_VALUE_SET_SUCCESS;\r\n        }\r\n        return FormFieldTypeElementStatus.META_KEY_NOT_EXISTS;\r\n    }\r\n\r\n    getInitialValue(): any {\r\n        return null;\r\n    }\r\n\r\n    getInitialMeta(): Map<string, any> {\r\n        const meta = new Map();\r\n        meta.set(\"disabled\", false);\r\n        meta.set(\"dirty\", false);\r\n        return meta;\r\n    }\r\n\r\n    isSameType(otherType: FormFieldType): boolean {\r\n        return this.name === otherType.name;\r\n    }\r\n}\r\n\r\nexport class FormFieldTypeText extends FormFieldType {\r\n    private _area: boolean;\r\n\r\n    constructor() {\r\n        super(\"String\");\r\n        this._area = false;\r\n    }\r\n\r\n    area(value = true): this {\r\n        this._area = value;\r\n        return this;\r\n    }\r\n\r\n    asElementType(): string {\r\n        return this._area ? \"textarea\" : \"text\";\r\n    }\r\n}\r\n\r\nexport class FormFieldTypeNumber extends FormFieldType {\r\n    private _precision: number = 2;\r\n    constructor() {\r\n        super(\"Number\");\r\n    }\r\n\r\n    asElementType(): string {\r\n        return \"number\";\r\n    }\r\n}\r\n\r\nexport class FormFieldTypeDate extends FormFieldType {\r\n    constructor() {\r\n        super(\"Date\");\r\n    }\r\n\r\n    asElementType(): string {\r\n        return \"date\";\r\n    }\r\n\r\n    isEqual(a: any, b: any): boolean {\r\n        return a.toDateString() === b.toDateString();\r\n    }\r\n}\r\n\r\nexport class FormFieldTypeRadio extends FormFieldType {\r\n    constructor() {\r\n        super(\"Radio\");\r\n    }\r\n\r\n    asElementType(): string {\r\n        return \"radio\";\r\n    }\r\n\r\n    getInitialMeta(): Map<string, any> {\r\n        const meta = super.getInitialMeta();\r\n        meta.set(\"checked\", false);\r\n        return meta;\r\n    }\r\n\r\n    override getFieldValue(field: FormField): any {\r\n        return field.getMetaValue(\"checked\") ? field.getValue() : null;\r\n    }\r\n\r\n    override setFieldValue(field: FormField, newValue: any): any {\r\n        return field.setMetaValue(\"checked\", newValue != null && field.getValue() === newValue);\r\n    }\r\n\r\n    override getElementMetaValue(element: HTMLInputElement, metaKey: string): [any, FormFieldTypeElementStatus] {\r\n        const [value, status] = super.getElementMetaValue(element, metaKey);\r\n        if (status !== FormFieldTypeElementStatus.META_KEY_NOT_EXISTS) {\r\n            return [value, status];\r\n        }\r\n        if (metaKey === \"checked\") {\r\n            return [element.checked, FormFieldTypeElementStatus.META_VALUE_SUCCESSFULLY_RECEIVED];\r\n        }\r\n        return [undefined, FormFieldTypeElementStatus.META_KEY_NOT_EXISTS];\r\n    }\r\n\r\n    override setElementMetaValue(element: HTMLInputElement, metaKey: string, newValue: any): FormFieldTypeElementStatus {\r\n        const status = super.setElementMetaValue(element, metaKey, newValue);\r\n        if (status !== FormFieldTypeElementStatus.META_KEY_NOT_EXISTS) return status;\r\n        if (metaKey === \"checked\") {\r\n            element.checked = Boolean(newValue);\r\n            return FormFieldTypeElementStatus.META_VALUE_SET_SUCCESS;\r\n        }\r\n        return FormFieldTypeElementStatus.FAILED_TO_SET_META_VALUE;\r\n    }\r\n}\r\n\r\nexport class FormFieldTypeCheckbox extends FormFieldType {\r\n    constructor() {\r\n        super(\"Checkbox\");\r\n    }\r\n\r\n    asElementType(): string {\r\n        return \"checkbox\";\r\n    }\r\n\r\n    getInitialMeta(): Map<string, any> {\r\n        const meta = super.getInitialMeta();\r\n        meta.set(\"checked\", false);\r\n        return meta;\r\n    }\r\n\r\n    override getFieldValue(field: FormField): any {\r\n        const value = field.getValue();\r\n        if ([\"\", \"on\"].includes(value)) return field.getMetaValue(\"checked\");\r\n        return field.getMetaValue(\"checked\") ? value : null;\r\n    }\r\n\r\n    override setFieldValue(field: FormField, newValue: any): any {\r\n        if ([\"\", \"on\"].includes(field.getValue())) return field.setMetaValue(\"checked\", newValue);\r\n        return field.setMetaValue(\"checked\", newValue != null && field.getValue() === newValue);\r\n    }\r\n\r\n    override getElementMetaValue(element: HTMLInputElement, metaKey: string): [any, FormFieldTypeElementStatus] {\r\n        const [value, status] = super.getElementMetaValue(element, metaKey);\r\n        if (status !== FormFieldTypeElementStatus.META_KEY_NOT_EXISTS) {\r\n            return [value, status];\r\n        }\r\n        if (metaKey === \"checked\") {\r\n            return [element.checked, FormFieldTypeElementStatus.META_VALUE_SUCCESSFULLY_RECEIVED];\r\n        }\r\n        return [undefined, FormFieldTypeElementStatus.META_KEY_NOT_EXISTS];\r\n    }\r\n\r\n    override setElementMetaValue(element: HTMLInputElement, metaKey: string, newValue: any): FormFieldTypeElementStatus {\r\n        const status = super.setElementMetaValue(element, metaKey, newValue);\r\n        if (status !== FormFieldTypeElementStatus.META_KEY_NOT_EXISTS) return status;\r\n        if (metaKey === \"checked\") {\r\n            element.checked = Boolean(newValue);\r\n            return FormFieldTypeElementStatus.META_VALUE_SET_SUCCESS;\r\n        }\r\n        return FormFieldTypeElementStatus.FAILED_TO_SET_META_VALUE;\r\n    }\r\n}\r\n\r\nexport class FormFieldTypeSelect extends FormFieldType {\r\n    private _multiple: boolean;\r\n    private _of: FormFieldType;\r\n\r\n    constructor() {\r\n        super(\"select\");\r\n        this._multiple = false;\r\n        /**\r\n         * @type {FormFieldType}\r\n         */\r\n        this._of = FormFieldType.text();\r\n    }\r\n\r\n    asElementType(): string {\r\n        return this._multiple ? \"select-multiple\" : \"select-one\";\r\n    }\r\n\r\n    getInitialMeta(): Map<string, any> {\r\n        const meta = super.getInitialMeta();\r\n        meta.set(\"optionsInitialized\", false);\r\n        return meta;\r\n    }\r\n\r\n    multiple(value: boolean = true): this {\r\n        this._multiple = value;\r\n        return this;\r\n    }\r\n\r\n    of(type: FormFieldType): this {\r\n        this._of = type;\r\n        return this;\r\n    }\r\n\r\n    override getElementValue(element: HTMLSelectElement): [any, FormFieldTypeElementStatus] {\r\n        if (!FormFieldType.isFormElement(element)) {\r\n            return [undefined, FormFieldTypeElementStatus.INVALID_ELEMENT];\r\n        }\r\n        if (element.type !== this.asElementType()) {\r\n            return [undefined, FormFieldTypeElementStatus.TYPE_MISMATCH];\r\n        }\r\n        if (this._multiple) {\r\n            return [Array.from(element.selectedOptions, option => option.value), FormFieldTypeElementStatus.VALUE_SUCCESSFULLY_RECEIVED];\r\n        }\r\n        return [element.value, FormFieldTypeElementStatus.VALUE_SUCCESSFULLY_RECEIVED];\r\n    }\r\n\r\n    override setElementValue(element: HTMLSelectElement, newValue: any): FormFieldTypeElementStatus {\r\n        if (!FormFieldType.isFormElement(element)) {\r\n            return FormFieldTypeElementStatus.INVALID_ELEMENT;\r\n        }\r\n        if (element.type !== this.asElementType()) {\r\n            return FormFieldTypeElementStatus.TYPE_MISMATCH;\r\n        }\r\n        let options: (HTMLOptionElement | null)[];\r\n        if (this._multiple) {\r\n            options = newValue.map((value: any): HTMLOptionElement | null => {\r\n                return element.querySelector(`option[value=\"${value}\"]`);\r\n            });\r\n        } else {\r\n            options = [\r\n                element.querySelector(`option[value=\"${newValue}\"]`)\r\n            ]\r\n        }\r\n        if (options.some(option => option == null)) return FormFieldTypeElementStatus.FAILED_TO_SET_VALUE;\r\n        (options as HTMLOptionElement[]).forEach(option => {\r\n            option.selected = true;\r\n        });\r\n        return FormFieldTypeElementStatus.VALUE_SET_SUCCESS;\r\n    }\r\n}\r\n\r\nexport class FormFieldTypeObject extends FormFieldType {\r\n    constructor() {\r\n        super(\"Object\");\r\n    }\r\n\r\n    isEqual(a: any, b: any): boolean {\r\n        return deepEqual(a, b);\r\n    }\r\n}\r\n\r\nexport enum FormFieldChangeType {\r\n    Value,\r\n    MetaValue\r\n}\r\n\r\nexport interface FormFieldValueChange {\r\n    stateKey: string;\r\n    type: FormFieldChangeType.Value;\r\n    field: FormField;\r\n    oldValue: any;\r\n    newValue: any;\r\n    initiator: any;\r\n    processed: boolean;\r\n    last: boolean;\r\n    date: Date;\r\n}\r\n\r\nexport interface FormFieldMetaValueChange {\r\n    stateKey: string;\r\n    type: FormFieldChangeType.MetaValue;\r\n    field: FormField;\r\n    metaKey: string;\r\n    oldValue: any;\r\n    newValue: any;\r\n    initiator: any;\r\n    processed: boolean;\r\n    last: boolean;\r\n    date: Date;\r\n}\r\n\r\nexport type FormFieldChange = FormFieldValueChange | FormFieldMetaValueChange;\r\n\r\nexport class FormFieldChangesEvent extends Event {\r\n    constructor(public changes: FormFieldChange[]) {\r\n        super(\"changes\", { cancelable: true });\r\n    }\r\n}\r\n\r\ninterface FormFieldChangeFilter {\r\n    type?: FormFieldChangeType | null;\r\n    onlyCurrentState?: boolean;\r\n    last?: boolean | null;\r\n    processed?: boolean | null;\r\n}\r\n\r\ninterface FormFieldAnyChangeFilter extends FormFieldChangeFilter {\r\n    type?: FormFieldChangeType | null;\r\n    metaKey?: never;\r\n}\r\n\r\ninterface FormFieldValueChangeFilter extends FormFieldChangeFilter {\r\n    type: FormFieldChangeType.Value;\r\n    metaKey?: never;\r\n}\r\n\r\ninterface FormFieldMetaValueChangeFilter extends FormFieldChangeFilter {\r\n    type: FormFieldChangeType.MetaValue;\r\n    metaKey?: string | null;\r\n}\r\n\r\nexport class FormFieldChangeSet {\r\n    private _changes: FormFieldChange[];\r\n    private _maxSize: number;\r\n\r\n    constructor(maxSize = 128) {\r\n        this._changes = [];\r\n        this._maxSize = maxSize;\r\n    }\r\n\r\n    trimProcessedChanges() {\r\n        while (this._changes.length > this._maxSize) {\r\n            const index = this._changes.findIndex(c => c.processed);\r\n            if (index === -1) break;\r\n            this._changes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    add(change: FormFieldChange): void {\r\n        let lastChange: FormFieldChange | undefined | null = null;\r\n        if (change.type === FormFieldChangeType.Value) {\r\n            lastChange = this.getFieldChange(change.field, { type: FormFieldChangeType.Value });\r\n        } else if (change.type === FormFieldChangeType.MetaValue) {\r\n            lastChange = this.getFieldChange(change.field, { type: FormFieldChangeType.MetaValue, metaKey: change.metaKey });\r\n        }\r\n        if (lastChange != null) {\r\n            lastChange.last = false;\r\n        }\r\n        this._changes.push(change);\r\n        this.trimProcessedChanges();\r\n    }\r\n\r\n    remove(change: FormFieldChange): void {\r\n        this._changes.splice(this._changes.indexOf(change), 1);\r\n    }\r\n\r\n    getFieldChange(field: FormField, filter: FormFieldValueChangeFilter): FormFieldValueChange | undefined;\r\n    getFieldChange(field: FormField, filter: FormFieldMetaValueChangeFilter): FormFieldMetaValueChange | undefined;\r\n    getFieldChange(field: FormField, filter: FormFieldAnyChangeFilter): FormFieldChange | undefined;\r\n    getFieldChange(field: FormField, { onlyCurrentState = true, last = true, processed = false, type = null, metaKey = null }: FormFieldAnyChangeFilter | FormFieldValueChangeFilter | FormFieldMetaValueChangeFilter = {}): FormFieldChange | undefined {\r\n        let changes = this.getFieldChanges(field, { onlyCurrentState, last, processed, type });\r\n        if (type === FormFieldChangeType.MetaValue && metaKey != null) {\r\n            changes = (changes as FormFieldMetaValueChange[]).filter(change => change.metaKey === metaKey);\r\n        }\r\n        return changes.at(-1);\r\n    }\r\n\r\n    getFieldChanges(field: FormField, filter?: FormFieldValueChangeFilter): FormFieldValueChange[];\r\n    getFieldChanges(field: FormField, filter?: FormFieldMetaValueChangeFilter): FormFieldMetaValueChange[];\r\n    getFieldChanges(field: FormField, filter?: FormFieldAnyChangeFilter): FormFieldChange[];\r\n    getFieldChanges(field: FormField, { onlyCurrentState = true, last = true, processed = false, type = null }: FormFieldAnyChangeFilter | FormFieldValueChangeFilter | FormFieldMetaValueChangeFilter = {}): FormFieldChange[] {\r\n        let changes = this._changes.filter(change => change.field === field);\r\n        if (type != null) { changes = changes.filter(change => change.type === type); }\r\n        if (last != null) { changes = changes.filter(change => change.last === last); }\r\n        if (processed != null) { changes = changes.filter(change => change.processed === processed); }\r\n        if (onlyCurrentState) { changes = changes.filter(change => change.stateKey === field.currentStateKey); }\r\n        return changes\r\n    }\r\n\r\n    hasChanges(field: FormField): boolean {\r\n        return this.getFieldChanges(field, { onlyCurrentState: true, last: true }).length !== 0;\r\n    }\r\n\r\n    markProcessed(changes: FormFieldChange[]): void {\r\n        changes.forEach(change => { change.processed = true; });\r\n        this.trimProcessedChanges();\r\n    }\r\n\r\n    static asChangedName(change: FormFieldChange): string | null {\r\n        if (change.type === FormFieldChangeType.Value) {\r\n            return change.field.name;\r\n        }\r\n        if (change.type === FormFieldChangeType.MetaValue) {\r\n            return getMetaDependencyKey(change.field.name, change.metaKey);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    static asChangedNames(changes: FormFieldChange[]): Set<string> {\r\n        const changedNames = new Set<string>();\r\n        for (const change of changes) {\r\n            const changedName = this.asChangedName(change);\r\n            if (changedName == null) continue;\r\n            changedNames.add(changedName);\r\n        }\r\n        return changedNames;\r\n    }\r\n\r\n    processChanges(field: FormField, type: FormFieldChangeType | null = null, dryRun: boolean = false): Set<string> {\r\n        const lastChanges = this.getFieldChanges(field, { onlyCurrentState: true, type });\r\n        if (!dryRun) {\r\n            this.markProcessed(this.getFieldChanges(field, { onlyCurrentState: true, last: null, type }));\r\n            field.dispatchEvent(new FormFieldChangesEvent(lastChanges));\r\n        }\r\n        return FormFieldChangeSet.asChangedNames(lastChanges);\r\n    }\r\n}\r\n\r\nexport interface FormFieldContext {\r\n    stateKey?: string | null;\r\n    initiator?: any | null;\r\n    processChanges?: boolean;\r\n    disabledIsNull?: boolean;\r\n    raw?: boolean;\r\n}\r\n\r\nexport class FormField extends EventTarget {\r\n    private _name: string;\r\n    private _type: FormFieldType;\r\n    private _changeSet: FormFieldChangeSet;\r\n    private _initializedStateKeys: Set<string>;\r\n    private _initialValue: any;\r\n    private _valueMap: Map<string, any>;\r\n    private _initialMeta: Map<string, any>;\r\n    private _metaMap: Map<string, Map<string, any>>;\r\n    private _currentStateKey: string;\r\n\r\n    constructor(name: string, type: FormFieldType, { changeSet = null, effectManager = null }: { changeSet?: FormFieldChangeSet | null, effectManager?: EffectManager | null } = {}) {\r\n        super();\r\n        this._name = name;\r\n        this._type = type;\r\n        this._initializedStateKeys = new Set();\r\n\r\n        this._initialValue = this.type.getInitialValue();\r\n        this._valueMap = new Map();\r\n\r\n        this._initialMeta = this.type.getInitialMeta();\r\n        this._metaMap = new Map();\r\n\r\n        this._changeSet = changeSet ?? new FormFieldChangeSet(32);\r\n        this._currentStateKey = \"default\";\r\n        this.initializeState({ stateKey: \"default\" });\r\n        if (effectManager != null) {\r\n            this.initializeDependencies(effectManager);\r\n        }\r\n    }\r\n\r\n    get self(): this {\r\n        return this;\r\n    }\r\n\r\n    get currentStateKey() {\r\n        return this._currentStateKey;\r\n    }\r\n\r\n    get context(): FormFieldContext {\r\n        return {\r\n            disabledIsNull: true,\r\n            initiator: null,\r\n            stateKey: null,\r\n            raw: false,\r\n            processChanges: false\r\n        };\r\n    }\r\n\r\n    get changeSet(): FormFieldChangeSet {\r\n        return this._changeSet;\r\n    }\r\n\r\n    get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    get type(): FormFieldType {\r\n        return this._type;\r\n    }\r\n\r\n    clearInitialMeta(): void {\r\n        this._initialMeta = new Map();\r\n    }\r\n\r\n    reset({ stateKey = null, initiator = null, processChanges = false }: FormFieldContext = {}): Set<string> {\r\n        stateKey ??= this._currentStateKey;\r\n        console.log(\"[FormField.reset] Reset state `%s` for field `%s`\", stateKey, this.name);\r\n        this.setValue(this._initialValue, { raw: true, stateKey, initiator });\r\n        for (const [metaKey, value] of this._initialMeta.entries()) {\r\n            this.setMetaValue(metaKey, value, { raw: true, stateKey, initiator });\r\n        }\r\n        return this.processChanges(null, !processChanges);\r\n    }\r\n\r\n    initializeState({ stateKey, initiator = null }: FormFieldContext & { stateKey: string }): void {\r\n        if (!this._initializedStateKeys.has(stateKey)) {\r\n            console.log(\"[FormField.initializeState] Initializing state key `%s` for field `%s`\", stateKey, this.name);\r\n            this._initializedStateKeys.add(stateKey);\r\n            this._valueMap.set(stateKey, null);\r\n            this._metaMap.set(stateKey, new Map());\r\n            this.reset({ stateKey, initiator, processChanges: true });\r\n        }\r\n    }\r\n\r\n    switchState({ stateKey, initiator = null, processChanges = false }: FormFieldContext & { stateKey: string }): Set<string> {\r\n        console.log(\"[FormField.switchState] Switching state for field `%s` from `%s` to `%s`\", this.name, this._currentStateKey, stateKey);\r\n        this.initializeState({ stateKey, initiator });\r\n        const oldValue = this._valueMap.get(this._currentStateKey);\r\n        const newValue = this._valueMap.get(stateKey);\r\n        if (!this.type.isEqual(oldValue, newValue)) {\r\n            const change: FormFieldChange = {\r\n                stateKey,\r\n                type: FormFieldChangeType.Value,\r\n                field: this,\r\n                initiator,\r\n                oldValue,\r\n                newValue,\r\n                date: new Date(),\r\n                last: true,\r\n                processed: false\r\n            };\r\n            this.changeSet.add(change);\r\n        }\r\n\r\n        for (const [metaKey, newValue] of this._metaMap.get(stateKey)!.entries()) {\r\n            const oldValue = this._metaMap.get(this._currentStateKey)!.get(metaKey);\r\n            if (oldValue !== newValue) {\r\n                const change: FormFieldChange = {\r\n                    stateKey,\r\n                    type: FormFieldChangeType.MetaValue,\r\n                    field: this,\r\n                    initiator,\r\n                    metaKey,\r\n                    oldValue,\r\n                    newValue,\r\n                    date: new Date(),\r\n                    last: true,\r\n                    processed: false\r\n                };\r\n                this.changeSet.add(change);\r\n            }\r\n        }\r\n        this._currentStateKey = stateKey;\r\n        return this.processChanges(null, !processChanges);\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {EffectManager} effectManager \r\n     */\r\n    initializeDependencies(effectManager: EffectManager) {\r\n        effectManager.addDependency(this.name, getMetaDependencyKey(this.name, \"disabled\"));\r\n        switch (this.type.asElementType()) {\r\n            case \"checkbox\":\r\n            case \"radio\":\r\n                effectManager.addDependency(this.name, getMetaDependencyKey(this.name, \"checked\"));\r\n                break;\r\n        }\r\n    }\r\n\r\n    getAdapter(outerContext: FormFieldContext) {\r\n        return new Proxy(this, {\r\n            get(target, propertyKey, receiver) {\r\n                switch (propertyKey) {\r\n                    case \"self\":\r\n                        return target;\r\n                    case \"context\":\r\n                        return outerContext;\r\n                    case \"getAdapter\":\r\n                        return (innerContext: FormFieldContext = {}) => target.getAdapter({ ...outerContext, ...innerContext });\r\n                    case \"getValue\":\r\n                        return (innerContext: FormFieldContext = {}) => target.getValue({ ...outerContext, ...innerContext });\r\n                    case \"getMetaValue\":\r\n                        return (metaKey: string, innerContext: FormFieldContext = {}) => target.getMetaValue(metaKey, { ...outerContext, ...innerContext });\r\n                    case \"setValue\":\r\n                        return (newValue: any, innerContext: FormFieldContext = {}) => target.setValue(newValue, { ...outerContext, ...innerContext });\r\n                    case \"setMetaValue\":\r\n                        return (metaKey: string, newValue: any, innerContext: FormFieldContext = {}) => target.setMetaValue(metaKey, newValue, { ...outerContext, ...innerContext });\r\n                    default:\r\n                        const value = Reflect.get(target, propertyKey, receiver);\r\n                        return typeof value === \"function\" ? value.bind(target) : value;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    getValue({ stateKey = null, raw = false, disabledIsNull = true }: FormFieldContext = {}): any {\r\n        if (raw) {\r\n            stateKey ??= this._currentStateKey\r\n            this.initializeState({ stateKey });\r\n            return this._valueMap.get(stateKey);\r\n        }\r\n        if (disabledIsNull && this.getMetaValue(\"disabled\", { stateKey })) {\r\n            return null;\r\n        }\r\n        return this.type.getFieldValue(this.getAdapter({ stateKey, raw: true }));\r\n    }\r\n\r\n    setInitialValue(newValue: any): void {\r\n        this._initialValue = newValue;\r\n    }\r\n\r\n    setValue(newValue: any, { stateKey = null, raw = false, initiator = null, processChanges = false }: FormFieldContext = {}): Set<string> {\r\n        if (raw) {\r\n            initiator ??= this;\r\n            stateKey ??= this._currentStateKey;\r\n            this.initializeState({ stateKey, initiator });\r\n            const oldValue = this.getValue({ stateKey, raw: true });\r\n            if (this.type.isEqual(oldValue, newValue)) return new Set();\r\n            this._valueMap.set(stateKey, newValue);\r\n            const change: FormFieldChange = {\r\n                stateKey,\r\n                type: FormFieldChangeType.Value,\r\n                field: this,\r\n                initiator,\r\n                oldValue,\r\n                newValue,\r\n                date: new Date(),\r\n                last: true,\r\n                processed: false\r\n            };\r\n            console.log(\"[FormField.setValue] Value changed:\", { oldValue, newValue, stateKey });\r\n            this.changeSet.add(change);\r\n            return this.processChanges(FormFieldChangeType.Value, !processChanges);\r\n        }\r\n        return this.type.setFieldValue(this.getAdapter({ stateKey, raw: true, processChanges, initiator }), newValue);\r\n    }\r\n\r\n    getMetaValue(metaKey: string, { stateKey = null, raw = false }: FormFieldContext = {}): any {\r\n        if (raw) {\r\n            stateKey ??= this._currentStateKey\r\n            this.initializeState({ stateKey });\r\n            const meta = this._metaMap.get(stateKey);\r\n            return meta!.get(metaKey);\r\n        }\r\n        return this.type.getFieldMetaValue(this.getAdapter({ raw: true, stateKey }), metaKey);\r\n    }\r\n\r\n    setInitialMetaValue(metaKey: string, newValue: any): void {\r\n        this._initialMeta.set(metaKey, newValue);\r\n    }\r\n\r\n    setMetaValue(metaKey: string, newValue: any, { stateKey = null, initiator = null, processChanges = false, raw = false }: FormFieldContext = {}): Set<string> {\r\n        if (raw) {\r\n            initiator ??= this;\r\n            stateKey ??= this._currentStateKey;\r\n            this.initializeState({ stateKey, initiator });\r\n            const oldValue = this.getMetaValue(metaKey, { stateKey });\r\n            if (oldValue === newValue) return new Set();\r\n            this._metaMap.get(stateKey)!.set(metaKey, newValue);\r\n            const change: FormFieldChange = {\r\n                stateKey,\r\n                type: FormFieldChangeType.MetaValue,\r\n                field: this,\r\n                initiator,\r\n                metaKey,\r\n                oldValue,\r\n                newValue,\r\n                date: new Date(),\r\n                last: true,\r\n                processed: false\r\n            };\r\n            this.changeSet.add(change);\r\n            console.log(\"[FormField.setMetaValue] Meta\", getMetaDependencyKey(this.name, metaKey), \"value changed:\", { oldValue, newValue, stateKey });\r\n            return this.processChanges(FormFieldChangeType.MetaValue, !processChanges);\r\n        }\r\n        return this.type.setFieldMetaValue(this.getAdapter({ stateKey, raw: true, initiator, processChanges }), metaKey, newValue);\r\n    }\r\n\r\n    processChanges(type: FormFieldChangeType | null = null, dryRun: boolean = false): Set<string> {\r\n        return this.changeSet.processChanges(this, type, dryRun);\r\n    }\r\n}\r\n\r\nexport class FormFieldArray {\r\n    constructor(public fieldArray: FormField[]) { }\r\n\r\n    getAdapter(outerContext: FormFieldContext) {\r\n        return new Proxy(this, {\r\n            get(target, propertyKey, receiver) {\r\n                switch (propertyKey) {\r\n                    case \"self\":\r\n                        return target;\r\n                    case \"context\":\r\n                        return outerContext;\r\n                    case \"getAdapter\":\r\n                        return (innerContext: FormFieldContext = {}) => target.getAdapter({ ...outerContext, ...innerContext });\r\n                    case \"getValue\":\r\n                        return (innerContext: FormFieldContext = {}) => target.getValue({ ...outerContext, ...innerContext });\r\n                    case \"getMetaValue\":\r\n                        return (metaKey: string, innerContext: FormFieldContext = {}) => target.getMetaValue(metaKey, { ...outerContext, ...innerContext });\r\n                    case \"setValue\":\r\n                        return (newValue: any, innerContext: FormFieldContext = {}) => target.setValue(newValue, { ...outerContext, ...innerContext });\r\n                    case \"setMetaValue\":\r\n                        return (metaKey: string, newValue: any, innerContext: FormFieldContext = {}) => target.setMetaValue(metaKey, newValue, { ...outerContext, ...innerContext });\r\n                    default:\r\n                        const value = Reflect.get(target, propertyKey, receiver);\r\n                        return typeof value === \"function\" ? value.bind(target) : value;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    getValue({ stateKey = null, disabledIsNull = true, raw = false }: FormFieldContext = {}): any {\r\n        return this.fieldArray.map(field => field.getValue({ stateKey, disabledIsNull, raw })).find(value => value != null);\r\n    }\r\n\r\n    getMetaValue(metaKey: string, { stateKey = null, raw = false }: FormFieldContext = {}): any {\r\n        return this.fieldArray.map(field => field.getMetaValue(metaKey, { stateKey, raw })).find(value => value != null);\r\n    }\r\n\r\n    setValue(value: any, { stateKey = null, initiator = null, processChanges = false, raw = false }: FormFieldContext = {}): Set<string> {\r\n        return this.fieldArray.map(field => field.setValue(value, { stateKey, initiator, processChanges, raw })).find(changedNames => changedNames.size !== 0) ?? new Set();\r\n    }\r\n\r\n    setMetaValue(metaKey: string, value: any, { stateKey = null, initiator = null, processChanges = false, raw = false }: FormFieldContext = {}): Set<string> {\r\n        return this.fieldArray.map(field => field.setMetaValue(metaKey, value, { stateKey, initiator, processChanges, raw })).find(changedNames => changedNames.size !== 0) ?? new Set();\r\n    }\r\n\r\n    processChanges(type: FormFieldChangeType | null = null, dryRun: boolean = false): Set<string> {\r\n        return this.fieldArray.map(field => field.processChanges(type, dryRun)).find(changedNames => changedNames.size !== 0) ?? new Set();\r\n    }\r\n}\r\n\r\nexport abstract class FormFieldLinker {\r\n    public field: FormField;\r\n    public type: FormFieldType;\r\n\r\n    constructor(field: FormField) {\r\n        this.field = field;\r\n        this.type = field.type;\r\n    }\r\n\r\n    abstract link(): void;\r\n    abstract unlink(): void;\r\n}\r\n\r\nexport class FormFieldElementLinker extends FormFieldLinker {\r\n    public element: FormElement;\r\n    private _mutationObserver: MutationObserver;\r\n    private _handleHideContainer: ((event: Event) => void) | null;\r\n    /**\r\n     * \r\n     * @param {FormField} field \r\n     * @param {Element} element \r\n     */\r\n    constructor(field: FormField, element: FormElement) {\r\n        super(field);\r\n        this.element = element;\r\n        if (this.type.asElementType() !== this.element.type) {\r\n            throw new Error(\"For link type is equal\")\r\n        }\r\n        this._fieldChangesEventListener = this._fieldChangesEventListener.bind(this);\r\n        this._elementValueInputEventListener = this._elementValueInputEventListener.bind(this);\r\n        this._elementValueChangeEventListener = this._elementValueChangeEventListener.bind(this);\r\n        this._handleHideContainer = null;\r\n        this._mutationObserver = new MutationObserver((mutations) => {\r\n            for (const mutation of mutations) {\r\n                if (mutation.type === \"attributes\") {\r\n                    switch (mutation.attributeName) {\r\n                        case \"disabled\":\r\n                            this._syncFieldMetaValue(\"disabled\");\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    override link(): void {\r\n        this.field.setInitialValue(this._getElementValue());\r\n        this.field.setInitialMetaValue(\"disabled\", this._getElementMetaValue(\"disabled\"));\r\n        this.field.setInitialMetaValue(\"visible\", true);\r\n        this.field.setInitialMetaValue(\"container\", this.element.parentElement);\r\n        if ([\"radio\", \"checkbox\"].includes(this.type.asElementType())) {\r\n            this.field.setInitialMetaValue(\"checked\", this._getElementMetaValue(\"checked\"));\r\n        }\r\n        this.field.reset({ processChanges: true, initiator: this });\r\n\r\n        this.field.addEventListener(\"changes\", this._fieldChangesEventListener);\r\n        if ([\"text\", \"number\", \"textarea\"].includes(this.type.asElementType())) {\r\n            this.element.addEventListener(\"input\", this._elementValueInputEventListener);\r\n        } else {\r\n            this.element.addEventListener(\"change\", this._elementValueChangeEventListener);\r\n        }\r\n\r\n        this._mutationObserver.observe(this.element, {\r\n            attributes: true,\r\n            attributeFilter: [\"disabled\"]\r\n        });\r\n    }\r\n\r\n    override unlink(): void {\r\n        this.field.removeEventListener(\"changes\", this._fieldChangesEventListener);\r\n        if ([\"text\", \"number\", \"textarea\"].includes(this.type.asElementType())) {\r\n            this.element.removeEventListener(\"input\", this._elementValueInputEventListener);\r\n        } else {\r\n            this.element.removeEventListener(\"change\", this._elementValueChangeEventListener);\r\n        }\r\n        this._mutationObserver.disconnect();\r\n    }\r\n\r\n    _elementValueInputEventListener(event: Event): void {\r\n        console.log(\"[FormFieldElementLinker._elementValueInputEventListener] Event\")\r\n        this.field.setMetaValue(\"dirty\", true, { initiator: this, processChanges: true });\r\n        this._syncFieldValue();\r\n    }\r\n\r\n    _elementValueChangeEventListener(event: Event): void {\r\n        this.field.setMetaValue(\"dirty\", true, { initiator: this, processChanges: true });\r\n        if ([\"radio\", \"checkbox\"].includes(this.type.asElementType())) {\r\n            this._syncFieldMetaValue(\"checked\");\r\n        } else {\r\n            this._syncFieldValue();\r\n        }\r\n    }\r\n\r\n    _fieldChangesEventListener(event: Event) {\r\n        const changes = (event as FormFieldChangesEvent).changes.filter(change => change.initiator !== this);\r\n        for (const change of changes) {\r\n            if (change.type === FormFieldChangeType.Value) {\r\n                this._syncElementValue();\r\n            } else if (change.type === FormFieldChangeType.MetaValue) {\r\n                this._syncElementMetaValue(change.metaKey);\r\n            }\r\n        }\r\n    }\r\n\r\n    _syncElementValue(): void {\r\n        console.log(\"[FormFieldElementLinker._syncElementValue] Syncing element value\");\r\n        const value = this.field.getValue({ raw: true });\r\n        const status = this.type.setElementValue(this.element, value);\r\n        if (status !== FormFieldTypeElementStatus.VALUE_SET_SUCCESS) {\r\n            console.log(\"[FormFieldElementLinker._syncElementMetaValue] Failed to set element value, status `%s`\", status);\r\n            return;\r\n        }\r\n    }\r\n\r\n    _getElementValue(): any {\r\n        const [value, status] = this.type.getElementValue(this.element);\r\n        if (status !== FormFieldTypeElementStatus.VALUE_SUCCESSFULLY_RECEIVED) {\r\n            console.warn(\"[FormFieldElementLinker._getElementValue] Failed to get value from element, status `%s`\", status);\r\n        }\r\n        return value;\r\n    }\r\n\r\n    _syncFieldValue(): void {\r\n        console.log(\"[FormFieldElementLinker._syncFieldValue] Syncing field value\");\r\n        this.field.setValue(this._getElementValue(), { initiator: this, processChanges: true, raw: true });\r\n    }\r\n\r\n    _syncElementMetaValue(metaKey: string): void {\r\n        console.log(\"[FormFieldElementLinker._syncElementMetaValue] Syncing element meta value\");\r\n        const value = this.field.getMetaValue(metaKey, { raw: true });\r\n        const status = this.type.setElementMetaValue(this.element, metaKey, value);\r\n        if (status === FormFieldTypeElementStatus.META_VALUE_SET_SUCCESS) {\r\n            return;\r\n        }\r\n        if (status === FormFieldTypeElementStatus.META_KEY_NOT_EXISTS) {\r\n            switch (metaKey) {\r\n                case \"visible\":\r\n                    const container = this.field.getMetaValue(\"container\") as HTMLElement;\r\n                    if (this._handleHideContainer != null) {\r\n                        container.removeEventListener(\"transitionend\", this._handleHideContainer);\r\n                        this._handleHideContainer = null;\r\n                    }\r\n                    if (value) {\r\n                        if (container.style.display === \"none\") {\r\n                            container.style.display = \"\";\r\n                            requestAnimationFrame(() => {\r\n                                container.dataset.visible = \"true\";\r\n                            });\r\n                        } else {\r\n                            container.dataset.visible = \"true\";\r\n                        }\r\n                    } else {\r\n                        if (container.style.display !== \"none\") {\r\n                            this._handleHideContainer = (event: Event) => {\r\n                                container.style.display = \"none\";\r\n                            };\r\n                            container.addEventListener(\"transitionend\", this._handleHideContainer, { once: true });\r\n                        }\r\n                        container.dataset.visible = \"false\";\r\n                    }\r\n                    break;\r\n                case \"autofill\":\r\n                    this.element.classList.toggle(\"autofill\", !!value);\r\n                    break;\r\n                case \"optionsInitialized\":\r\n                    // console.log(\"options initialized\", !!value);\r\n                    if (value) {\r\n                        this._syncElementValue();\r\n                    }\r\n                    break;\r\n            }\r\n            return;\r\n        }\r\n\r\n        console.log(\"[FormFieldElementLinker._syncElementMetaValue] Failed to set element meta value, status `%s`\", status);\r\n    }\r\n\r\n    _getElementMetaValue(metaKey: string): any {\r\n        const [value, status] = this.type.getElementMetaValue(this.element, metaKey);\r\n        if (status !== FormFieldTypeElementStatus.META_VALUE_SUCCESSFULLY_RECEIVED) {\r\n            console.warn(\"[FormFieldElementLinker._getElementMetaValue] Failed to get value from element, status `%s`\", status);\r\n        }\r\n        return value;\r\n    }\r\n\r\n    _syncFieldMetaValue(metaKey: string): void {\r\n        console.log(\"[FormFieldElementLinker._syncFieldMeta] Syncing field meta value\");\r\n        this.field.setMetaValue(metaKey, this._getElementMetaValue(metaKey), { initiator: this, processChanges: true });\r\n    }\r\n}\r\n\r\nexport class FormFields extends EventTarget {\r\n    public list: FormField[];\r\n\r\n    constructor() {\r\n        super();\r\n        this.list = [];\r\n        this._fieldChangesEventListener = this._fieldChangesEventListener.bind(this);\r\n    }\r\n\r\n    _fieldChangesEventListener(event: Event) {\r\n        this.dispatchEvent(new FormFieldChangesEvent((event as FormFieldChangesEvent).changes));\r\n    }\r\n\r\n    add(field: FormField) {\r\n        field = field.self;\r\n        if (this.list.includes(field)) return false;\r\n        field.addEventListener(\"changes\", this._fieldChangesEventListener);\r\n        this.list.push(field);\r\n        return true;\r\n    }\r\n\r\n    remove(field: FormField) {\r\n        field = field.self;\r\n        if (!this.list.includes(field)) return false;\r\n        field.removeEventListener(\"changes\", this._fieldChangesEventListener);\r\n        this.list.splice(this.list.indexOf(field), 1);\r\n        return true;\r\n    }\r\n\r\n    get(fieldName: string): FormField | FormFieldArray {\r\n        const fields = this.list.filter(field => field.name === fieldName)\r\n        return fields.length === 1 ? fields[0] : new FormFieldArray(fields);\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<string> {\r\n        return new Set(this.list.map(field => field.name)).values();\r\n    }\r\n}\r\n\r\nexport interface Option {\r\n    value: string;\r\n    textContent: string;\r\n}\r\n\r\nexport abstract class FormChangesManager {\r\n    abstract manage(form: Form, changes: FormFieldChange[]): void;\r\n}\r\n\r\nexport class FormChangesForRadioManager extends FormChangesManager {\r\n    override manage(form: Form, changes: FormFieldChange[]): void {\r\n        changes.filter(change =>\r\n            change.initiator !== form &&\r\n            change.field.type.asElementType() === \"radio\" &&\r\n            change.type === FormFieldChangeType.MetaValue &&\r\n            change.metaKey === \"checked\" &&\r\n            change.newValue\r\n        ).forEach(change => {\r\n            form.fields.list.filter(field =>\r\n                field.name === change.field.name &&\r\n                field.type.asElementType() === \"radio\" &&\r\n                field != change.field &&\r\n                field.getMetaValue(\"checked\")\r\n            ).forEach(field => {\r\n                field.setMetaValue(\"checked\", false, { initiator: form, processChanges: true });\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nexport class FormChangesForTriggerEffectsManager extends FormChangesManager {\r\n    override manage(form: Form, changes: FormFieldChange[]): void {\r\n        changes = changes.filter(change => change.initiator !== form);\r\n        if (changes.length === 0) return;\r\n        form.effectManager.triggerEffects({ changedNames: FormFieldChangeSet.asChangedNames(changes) });\r\n    }\r\n}\r\n\r\nexport class Form extends EventTarget {\r\n    public form: HTMLFormElement;\r\n    public effectManager: EffectManager;\r\n    public fields: FormFields;\r\n    public fieldLinkers: FormFieldLinker[];\r\n    public changeSet: FormFieldChangeSet;\r\n    private _changesManagers: FormChangesManager[];\r\n\r\n    constructor({ form }: { form: HTMLFormElement }) {\r\n        super();\r\n        this.form = form;\r\n        this.changeSet = new FormFieldChangeSet();\r\n        this.effectManager = new EffectManager();\r\n        this.fields = new FormFields();\r\n        this.fieldLinkers = [];\r\n        this._changesManagers = [];\r\n        this._handleChanges = this._handleChanges.bind(this);\r\n    }\r\n\r\n    async setup() {\r\n        if (this.form != null) {\r\n            this.form.classList.add(\"uoyroem-form\");\r\n            this.form.noValidate = true;\r\n\r\n            this.form.addEventListener(\"submit\", (event) => {\r\n                event.preventDefault();\r\n                this.submit().then(() => this.reset());\r\n            });\r\n\r\n            this.form.addEventListener(\"reset\", (event) => {\r\n                event.preventDefault();\r\n                this.reset();\r\n            });\r\n\r\n            this.fields.addEventListener(\"changes\", this._handleChanges);\r\n            this.registerChangesManager(new FormChangesForRadioManager());\r\n            this.registerChangesManager(new FormChangesForTriggerEffectsManager());\r\n            this.registerElements();\r\n        }\r\n    }\r\n\r\n    _handleChanges(event: Event) {\r\n        const changes = (event as FormFieldChangesEvent).changes;\r\n        for (const changesManager of this._changesManagers) {\r\n            changesManager.manage(this, changes);\r\n        }\r\n    }\r\n\r\n    registerChangesManager(changesManager: FormChangesManager) {\r\n        this._changesManagers.push(changesManager);\r\n    }\r\n\r\n    getFormData(): Record<string, any> {\r\n        const formData: Record<string, any> = {};\r\n        for (const fieldName of this.fields) {\r\n            formData[fieldName] = this.fields.get(fieldName).getValue();\r\n        }\r\n        return formData;\r\n    }\r\n\r\n    registerElements(): void {\r\n        for (const element of this.form.elements) {\r\n            if (!FormFieldType.isFormElement(element)) {\r\n                continue;\r\n            }\r\n            if (element.name === \"\") continue;\r\n            const field = new FormField(element.name, FormFieldType.fromFormElement(element), { changeSet: this.changeSet, effectManager: this.effectManager });\r\n            const fieldElementLinker = new FormFieldElementLinker(field, element);\r\n            fieldElementLinker.link();\r\n            this.fieldLinkers.push(fieldElementLinker);\r\n            this.fields.add(field);\r\n        }\r\n    }\r\n\r\n    getElement(name: string): Element | RadioNodeList | null {\r\n        return this.form.elements.namedItem(name);\r\n    }\r\n\r\n    async validate(): Promise<boolean> {\r\n        return true;\r\n    }\r\n\r\n    async submit(): Promise<void> {\r\n        if (!await this.validate()) {\r\n\r\n        }\r\n    }\r\n\r\n    reset(): void {\r\n        for (const field of this.fields.list) {\r\n            field.reset({ initiator: this });\r\n        }\r\n        this.effectManager.triggerEffects();\r\n    }\r\n\r\n    addDisableWhenEffect(fieldName: string, disableWhen: () => Promise<boolean> | boolean, dependsOn: string[]): void {\r\n        this.effectManager.addEffect(getMetaDependencyKey(fieldName, \"disabled\"), {\r\n            type: \"disable-when\",\r\n            callback: async () => {\r\n                const disabled = await disableWhen();\r\n                // console.log(`[Effect.DisableWhen] Field ${fieldName} disabled: `, disabled);\r\n                const field = this.fields.get(fieldName).getAdapter({ initiator: this });\r\n                return field.setMetaValue(\"disabled\", disabled, { processChanges: true });\r\n            },\r\n            dependsOn,\r\n        });\r\n    }\r\n\r\n    addVisibleWhenEffect(fieldName: string, visibleWhen: () => Promise<boolean> | boolean, dependsOn: string[]): void {\r\n        this.addDisableWhenEffect(fieldName, async () => !await visibleWhen(), dependsOn);\r\n        this.effectManager.addEffect(getMetaDependencyKey(fieldName, \"visible\"), {\r\n            type: \"visible-when\",\r\n            callback: async () => {\r\n                const visible = await visibleWhen();\r\n                // console.log(`[Effect.VisibleWhen] Field ${fieldName} visible: `, visible);\r\n                const field = this.fields.get(fieldName).getAdapter({ initiator: this });\r\n                return field.setMetaValue(\"visible\", visible, { processChanges: true });\r\n            },\r\n            dependsOn: [getMetaDependencyKey(fieldName, \"disabled\")]\r\n        });\r\n    }\r\n\r\n    addComputedFieldEffect(fieldName: string, fieldType: FormFieldType, compute: () => Promise<any> | any, dependsOn: string[]): void {\r\n        this.fields.add(new FormField(fieldName, fieldType, { changeSet: this.changeSet, effectManager: this.effectManager }))\r\n        this.effectManager.addEffect(fieldName, {\r\n            type: \"computed-field\",\r\n            callback: async () => {\r\n                const value = await compute();\r\n                // console.log(`[Effect.ComputedField] Field ${fieldName} value: `, value);\r\n                const field = this.fields.get(fieldName);\r\n                return field.setValue(value, { initiator: this, processChanges: true });\r\n            },\r\n            dependsOn\r\n        });\r\n    }\r\n\r\n    addFieldAutofillEffect(fieldName: string, autofillWith: () => Promise<any> | any, dependsOn: string[]): void {\r\n        this.effectManager.addDependency(fieldName, getMetaDependencyKey(fieldName, \"autofill\"));\r\n        this.effectManager.addEffect(getMetaDependencyKey(fieldName, \"autofill\"), {\r\n            type: \"field-autofill\",\r\n            callback: async () => {\r\n                const field = this.fields.get(fieldName).getAdapter({ initiator: this });\r\n                const dirty = field.getMetaValue(\"dirty\");\r\n                field.setMetaValue(\"autofill\", !dirty);\r\n                if (dirty) {\r\n                    return field.processChanges();\r\n                }\r\n                const value = await autofillWith();\r\n                // console.log(`[Effect.FieldAutofill] Field ${fieldName} value: `, value);\r\n                field.setMetaValue(\"autofill\", field.setValue(value).size !== 0);\r\n                return field.processChanges();\r\n            },\r\n            dependsOn: [getMetaDependencyKey(fieldName, \"dirty\"), ...dependsOn]\r\n        });\r\n    }\r\n\r\n    addSelectOptionsInitializerEffect(fieldName: string, getDefaultOption: () => Promise<Option> | Option, getOptions: () => Promise<Option[]> | Option[], dependsOn: string[]): void {\r\n        this.effectManager.addEffect(fieldName, {\r\n            type: \"select-options-initializer\",\r\n            callback: async () => {\r\n                const defaultOption = await getDefaultOption();\r\n                const options = await getOptions();\r\n                const selectElement = this.getElement(fieldName) as HTMLSelectElement;\r\n                const field = this.fields.get(fieldName).getAdapter({ initiator: this });\r\n                const selectedValue = field.getValue({ disabledIsNull: false });\r\n                field.setValue(defaultOption.value);\r\n                selectElement.innerHTML = \"\";\r\n                for (const option of [defaultOption, ...options]) {\r\n                    const optionElement = document.createElement(\"option\");\r\n                    optionElement.value = option.value;\r\n                    optionElement.textContent = option.textContent;\r\n                    selectElement.options.add(optionElement);\r\n                }\r\n                field.setValue(selectedValue);\r\n                field.setMetaValue(\"disabled\", options.length === 0);\r\n                field.setMetaValue(\"optionsInitialized\", options.length !== 0);\r\n                return field.processChanges();\r\n            },\r\n            dependsOn\r\n        });\r\n    }\r\n}","/**\r\n *   `FormAction`:\r\n * -    \r\n * -       \r\n * - \r\n */\r\n// enum StateRequestType1 {\r\n\r\n// }\r\n// class FormActionRequestType {\r\n//     constructor(public readonly description: string) { }\r\n// }\r\n// const actions = {\r\n//     GetFieldValue: new FormActionRequestType(\"GetFieldValue\"),\r\n//     GetFieldMetaValue: new FormActionRequestType(\"GetFieldMetaValue\"),\r\n//     SetFieldValue: new FormActionRequestType(\"SetFieldValue\"),\r\n//     SetFieldMetaValue: new FormActionRequestType(\"SetFieldMetaValue\"),\r\n//     GetElementValue: new FormActionRequestType(\"GetElementValue\"),\r\n//     GetElementMetaValue: new FormActionRequestType(\"GetElementMetaValue\"),\r\n//     SetElementValue: new FormActionRequestType(\"SetElementValue\"),\r\n//     SetElementMetaValue: new FormActionRequestType(\"SetElementMetaValue\"),\r\n//     SyncFieldValueFromElement: new FormActionRequestType(\"SyncFieldValueFromElement\"),\r\n//     SyncElementValueFromField: new FormActionRequestType(\"SyncElementValueFromField\"),\r\n//     SyncFieldMetaValueFromElement: new FormActionRequestType(\"SyncFieldMetaValueFromElement\"),\r\n//     SyncElementMetaValueFromField: new FormActionRequestType(\"SyncElementMetaValueFromField\"),\r\n// }\r\n\r\n\r\n\r\n\r\n\r\nexport interface FormActionRequestBody { }\r\nexport interface FormActionResponseBody { }\r\n\r\nexport class FormActionRequest<Body extends FormActionRequestBody> {\r\n    constructor(public body: Body) { }\r\n}\r\n\r\nexport class FormActionResponseStatus {\r\n    static instances: FormActionResponseStatus[] = [];\r\n    static get(code: number): FormActionResponseStatus {\r\n        let instance = this.instances.find(instance => instance.code === code);\r\n        if (instance == null) throw new Error(`Form action response status with code \"${code}\" not exists`)\r\n        return instance;\r\n    }\r\n    static getOrCreate(code: number, description: string): FormActionResponseStatus {\r\n        let instance = this.instances.find(instance => instance.code === code);\r\n        if (instance != null) { return instance; }\r\n        instance = new FormActionResponseStatus(code, description)\r\n        this.instances.push(instance);\r\n        return instance;\r\n    }\r\n\r\n    static Success: FormActionResponseStatus;\r\n\r\n    static {\r\n        this.Success = this.getOrCreate(1, \"OK\");\r\n    }\r\n\r\n    private constructor(public readonly code: number, public readonly description: string) { }\r\n}\r\n\r\nexport class FormActionResponse<Body extends FormActionResponseBody> {\r\n    constructor(public body: Body, public status: FormActionResponseStatus) {\r\n    }\r\n}\r\n\r\nexport abstract class FormActionHandler<RequestBody extends FormActionRequestBody, ResponseBody extends FormActionResponseBody> {\r\n    abstract handle(request: FormActionRequest<RequestBody>, registry: FormActionRegistry): Promise<FormActionResponse<ResponseBody>>;\r\n}\r\n\r\nexport abstract class FormActionMiddleware<RequestBody extends FormActionRequestBody, ResponseBody extends FormActionResponseBody> {\r\n    constructor(public readonly registry: FormActionRegistry = FormActionRegistry.instance) { }\r\n\r\n    abstract handle(request: FormActionRequest<RequestBody>, getResponse: () => Promise<FormActionResponse<ResponseBody>>): Promise<FormActionResponse<ResponseBody>>;\r\n}\r\n\r\nexport class FormActionType {\r\n    constructor(public readonly code: number) {\r\n\r\n    }\r\n}\r\n\r\nexport class FormAction<RequestBody extends FormActionRequestBody, ResponseBody extends FormActionResponseBody> {\r\n    public middlewares: FormActionMiddleware<RequestBody, ResponseBody>[];\r\n    constructor(public handler: FormActionHandler<RequestBody, ResponseBody>) {\r\n        this.middlewares = [];\r\n    }\r\n\r\n    async addMiddleware(middleware: FormActionMiddleware<RequestBody, ResponseBody>) {\r\n        this.middlewares.push(middleware);\r\n    }\r\n\r\n    async handle(request: FormActionRequest<RequestBody>, registry: FormActionRegistry): Promise<FormActionResponse<ResponseBody>> {\r\n        return await this.middlewares.reduceRight(\r\n            (getResponse, middleware) => {\r\n                return async () => await middleware.handle(request, getResponse);\r\n            },\r\n            async () => this.handler.handle(request, registry)\r\n        )();\r\n    }\r\n}\r\n\r\nexport class FormActionRegistry {\r\n    private constructor(public readonly parent?: FormActionRegistry) { }\r\n\r\n    static readonly instance: FormActionRegistry = new FormActionRegistry();\r\n\r\n    context(parent: FormActionRegistry = FormActionRegistry.instance): FormActionRegistry {\r\n        return new FormActionRegistry(parent);\r\n    }\r\n\r\n    getActionMiddlewares<RequestBody extends FormActionRequestBody, ResponseBody extends FormActionResponseBody>(action: FormAction<RequestBody, ResponseBody>) {\r\n        const registries: FormActionRegistry[] = [];\r\n        let registry: FormActionRegistry | undefined = this;\r\n        while (registry != null) {\r\n            registries.push(registry);\r\n            registry = registry.parent;\r\n        }\r\n        return action.middlewares.filter(middleware => registries.includes(middleware.registry))\r\n    }\r\n\r\n    async fetch<RequestBody extends FormActionRequestBody, ResponseBody extends FormActionResponseBody>(action: FormAction<RequestBody, ResponseBody>, request: FormActionRequest<RequestBody>): Promise<FormActionResponse<ResponseBody>> {\r\n        return action.handle(request, this);\r\n    }\r\n}\r\n\r\nexport const formActions = FormActionRegistry.instance;"],"names":["Event","EventTarget","Symbol","iterator","FormActionResponseStatus","static","get","code","instance","this","instances","find","Error","getOrCreate","description","push","Success","constructor","FormActionRegistry","parent","context","arguments","length","undefined","getActionMiddlewares","action","registries","registry","middlewares","filter","middleware","includes","fetch","request","handle"],"sourceRoot":""}